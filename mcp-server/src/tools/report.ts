/**
 * Report Tool — Formats audit results as JSON or Markdown.
 *
 * Accepts raw audit output and reformats it for consumption.
 * Markdown mode produces a human-readable report suitable for sharing.
 */

import { type McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { type ModuleBreakdown } from "../analysis/scoring.js";

interface AuditResult {
  target?: { package?: string; device?: string; mode?: string };
  duration_seconds?: number;
  rasp_sdk?: { sdk_id: string; display_name: string; confidence: number; matched_indicators: string[] } | null;
  risk_score: number;
  module_breakdown: ModuleBreakdown[];
  bonuses?: { reason: string; points: number }[];
  total_events?: number;
}

export function registerReportTool(server: McpServer): void {
  server.tool(
    "sentinellium_report",
    "Format Sentinellium audit results as JSON or Markdown. " +
    "Pass the raw audit output from sentinellium_audit.",
    {
      audit_result: z.string().describe("JSON string from sentinellium_audit output"),
      format: z.enum(["json", "markdown"]).default("markdown").describe("Output format"),
    },
    async ({ audit_result, format }) => {
      let result: AuditResult;
      try {
        result = JSON.parse(audit_result) as AuditResult;
      } catch {
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({ status: "error", error: "Invalid JSON in audit_result" }),
          }],
        };
      }

      if (format === "json") {
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify(result, null, 2),
          }],
        };
      }

      // Markdown format
      const md = formatMarkdown(result);
      return {
        content: [{ type: "text" as const, text: md }],
      };
    },
  );
}

function formatMarkdown(result: AuditResult): string {
  const lines: string[] = [];
  const pkg = result.target?.package ?? "unknown";
  const device = result.target?.device ?? "unknown";
  const duration = result.duration_seconds ?? 0;

  lines.push(`# Sentinellium RASP Audit Report`);
  lines.push("");
  lines.push(`**Target:** \`${pkg}\`  `);
  lines.push(`**Device:** \`${device}\`  `);
  lines.push(`**Duration:** ${duration}s  `);
  lines.push(`**Mode:** ${result.target?.mode ?? "attach"}`);
  lines.push("");

  // Risk score
  lines.push(`## Risk Score: ${result.risk_score}/100`);
  lines.push("");
  const level = result.risk_score >= 70 ? "HIGH" : result.risk_score >= 40 ? "MEDIUM" : "LOW";
  lines.push(`**Risk Level:** ${level}`);
  lines.push("");

  // RASP SDK identification
  lines.push(`## RASP SDK`);
  lines.push("");
  if (result.rasp_sdk && result.rasp_sdk.sdk_id !== "none") {
    lines.push(`**Detected:** ${result.rasp_sdk.display_name}  `);
    lines.push(`**Confidence:** ${result.rasp_sdk.confidence}%  `);
    if (result.rasp_sdk.matched_indicators.length > 0) {
      lines.push(`**Indicators:**`);
      for (const ind of result.rasp_sdk.matched_indicators) {
        lines.push(`- \`${ind}\``);
      }
    }
  } else {
    lines.push("No RASP SDK identified. The app may be unprotected or using an unknown SDK.");
  }
  lines.push("");

  // Module breakdown
  lines.push(`## Module Breakdown`);
  lines.push("");
  lines.push(`| Module | Events | Errors | Warnings | Info | Score |`);
  lines.push(`|--------|--------|--------|----------|------|-------|`);
  for (const mod of result.module_breakdown) {
    lines.push(
      `| ${mod.module} | ${mod.events} | ${mod.errors} | ${mod.warnings} | ${mod.infos} | ${mod.score} |`,
    );
  }
  lines.push("");

  // Bonuses
  if (result.bonuses && result.bonuses.length > 0) {
    lines.push(`## Score Bonuses`);
    lines.push("");
    for (const bonus of result.bonuses) {
      lines.push(`- **+${bonus.points}:** ${bonus.reason}`);
    }
    lines.push("");
  }

  // Footer
  lines.push("---");
  lines.push(`*Generated by Sentinellium v0.1.0 — ${new Date().toISOString()}*`);

  return lines.join("\n");
}
